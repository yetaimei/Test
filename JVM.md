## 《深入理解Java虚拟机》精华整理 - 自动内存管理

> 21天学会C语言？3天学会弹钢琴？
>
> 放弃一切错误方法，从今天开始“刻意练习”，
>
> 因为这才是最强大的，也是唯一正确的学习方法。
>
> --《刻意练习》Anders Ericsson著





关于JVM，知识主要应用于线上机器调优（所以面试也会经常问到），本文思路三步走：**1.原理 2.工具 3.实践**。整理成笔记，把精华部分过滤出来给我的读者。



> Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。
>
> 对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。

比如我在[《2020 Offer收割机》| 线程安全法则|5分钟揭秘线程池](https://juejin.im/post/5df9eb1d51882512727f2aa9)提到：**在for循环中创建线程池，犯忌讳。**这样会导致线程池占用的内存会越来越多，就会导致频繁fullGC甚至OOM。



![image-20200326112254309](https://tva1.sinaimg.cn/large/00831rSTly1gd75zh5hb8j30rg0n6guf.jpg)

内存模型太重要了，这个图时间久就忘记了，小口诀：左堆右栈

堆：（看做一棵完全二叉树的数组对象）

1. 方法区
2. Heap堆

栈：（**链表**，子弹夹结构，先进后出）

1. 虚拟机栈
2. 本地方法栈
3. 程序计数器

### 面试官：堆是一种什么数据结构

堆是一类特殊的树，堆的通用特点就是父节点会大于或小于所有子节点，通常堆数据结构是使用完全二叉树来存储的，但是堆并不等于完全二叉树，例如二项堆，斐波那契堆，就不属于二叉树。

<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdmf8cc3trj30v60u0wse.jpg" alt="image-20200408160603683" style="zoom: 33%;" />

### 堆数据结构有什么优势？为什么会发明这种数据结构？

线性有序数组可以代替完全二叉树吗？当然不太好，因为线性数组插入的时候从数组中留出空位就需要![[公式]](https://www.zhihu.com/equation?tex=O%28n%29)的时间复杂度，删除的时候亦然。



### 什么是完全二叉树？什么是满二叉树？

**满二叉树**：二叉树除了叶结点外所有节点都有两个子节点。

![img](https://tva1.sinaimg.cn/large/00831rSTly1gdmfpzstzaj309d083wfc.jpg)

**完全二叉树**：从根往下数，除了最下层外都是全满（都有两个子节点），而最下层所有叶结点都向左边靠拢填满。
构造一颗完全二叉树就是**【从上到下，从左往右】**的放置节点。

![img](https://tva1.sinaimg.cn/large/00831rSTly1gdmfr5ppvsj309n07dab0.jpg)

## 堆和普通树的区别

堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：

**节点的顺序：**在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。

**内存占用：**普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额外的内存。堆仅仅使用一个数据来存储数组，且不使用指针。

**平衡：**二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到**O(log n)**。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证**O(log n)** 的性能。

**搜索：**在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。

## 1.程序计数器（行号指示器）

理解这句话：字节码的行号指示器，每条线程都需要有一个独立的程序计数器。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能

> 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。



## 2.Java虚拟机栈 Stack（存储局部变量表、操作数栈、动态连接、方法出口等信息）方法被执行的时候，Java虚拟机都会同步创建一个栈帧

每条线程都需要有一个独立的，生命周期与线程相同

> 虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
>
> 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。



**如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。**



## 3.本地方法栈

还是英文名字比较好记录：Native Method Stacks

> 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

这个没什么好说的，很好理解。一般我们了解一个api的源码，到了本地方法这个层面就可以了。



hotsopt虚拟机不区分虚拟机栈 和 本地方法栈。通过-Xss参数设置

---------



开始说堆

## 4.Java堆

Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。

new 出来的对象，就是在这个区域。

在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。

一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）

从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。

```
jvm.xmx=2048
jvm.xms=2048
jvm.metaspacesize=128
jvm.maxmetaspacesize=256
jvm.xmn=1024

env.config=prod

logger.root.level=info
logger.root.appender=<AppenderRef ref="daily"/><AppenderRef ref="Sentry"/>
```

这是我线上某个to B业务的机器，jvm.xmx=2048  jvm.xms=2048 ，仅2G。



## 5.方法区（常量池）

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域

> 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。

在JDK 8以前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），Java8以后，可以忘掉永久带这个概念了。



# 垃圾回收算法

1. 引用计数法，java虚拟机并不会使用此方法，因为不能解决相互引用。
2. 可达性分析法，只要到GC Root 不可达，就代表死了。主流商业虚拟就都采用此方法。

## 引用的4种类型

1. 强引用：Object o = new Object
2. 软引用：有用非必须的对象，发生内存溢出的情况下收回来，如果空间还是不够再抛异常
3. 弱引用：非必须对象，只能活过一次GC。
4. 虚引用：幽灵引用

## 回收算法

1. 分代回收算法：新生代/老年代/
2. 标记清除算法
3. 标记复制算法：商用虚拟机大多采用此方法回收新生代。
   缺点：产生大量内存碎片，内存使用以来内存分配链表，这样对读操作不利，因为读是最频繁的操作。
4. 标记整理算法：老年代采用此方法合适。这种算法“移动对象”时会存在stop the world的情况。



## 垃圾收集器

1. **Serial 单线程收集器 stop the world** 

2. **ParNew 多线程收集器 Serial的并行版**

3. **CMS：Concurrent Mark Sweep ，停顿时间短，因为名字就是Mark Sweep ，所以是基于标记清除算法的收集器。**

   1. 初始标记：会stop，标记GC Root 是否直接关联对象，速度快。
   2. 并发标记：标记GC Root的关联对象遍历整个对象图的过程，耗费时间久，但是不会Stop。
   3. 重新标记：会stop ，修正并发标记期间因用户程序继续运行标记变动的对象。
   4. 并发清除：清除对象。整个过程，最耗时的就是并发标记和并发清除。

   缺点：对CPU资源敏感，会分走CPU资源，清除算法产生垃圾碎片。通过参数设置，再Full GC前先进行整理碎片工作。

4. **Parallel Scavenge 吞吐量优先收集器：标记复制算法，并行收集，和 ParNew类似，**

5. **Serial Old 是 Serial的老年代版本，单线程收集器，标记整理算法。**

6. **Parallel Old 是 Parallel Scavenge 的老年代版本，多线程并发操作。标记整理算法。**

7. **G1:可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集这些创新性设计。**

   1. 初始标记：标记一下GC Roots能直接关联到的对象，这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
   2. 并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。
   3. 最终标记：
   4. 筛选回收

   

   

### ZGC的核心问题——并发整理算法的实现

染色指针技术：Colored Pointer ，ZGC的染色指针是最直接的、最纯粹的，它直接把标记信息记在引用对象的指针上，这时，与其说可达性分析是遍历对象图来标记对象，还不如说是遍历“引用图”来标记“引用”了。

1. 并发标记（Concurrent Mark）
2. 并发预备重分配（Concurrent Prepare for Relocate）
3. 并发重分配（Concurrent Relocate）

CMS收集器使用什么算法？

标记清除算法？



## 如何使用常用jvm命令优化性能？如何巧妙的记住几个常用的jvm命令。

看了好几次我发现都记不住这几个常用命令，于是我把一次jvm调优案例串联起来这个命令，发现很好记住。

1. jcmd将诊断命令发送到正在运行的jvm上。
2. 使用jps命令查看jvm进程状况工具查看虚拟机进程状况，使用jstack命令获取Java堆栈跟踪工具，也就是线程运行情况，当然，也可以使用java.lang.Thread类新增了一个getAllStackTraces()方法获取虚拟机中所有线程情况，我猜美团JVM线上监控工具就是用的这个方法，而不是使用jvm命令或者脚本。
3. 使用jstat命令，虚拟机统计信息监视工具，比如 jstat -gc 监视内存带情况，-class获取类装载卸载情况。
4. 使用jinfo命令查看虚拟机各项参数配置，调整参数。
5. 使用jmap命令获取堆转储快照， jhat：虚拟机堆转储快照分析工具。

大内存机器如何充分利用好资源？

逻辑分区，负载均衡下做集群，小内存使用CMS作为首选GC。



## Class类文件结构

如果想了解更多class文件结构，不如直接看《Java虚拟机规范》，





## 名次解释

操作数：用来被操作的数，也就是我们方法里的参数。Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成